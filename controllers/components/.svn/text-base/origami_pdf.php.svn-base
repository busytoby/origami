<?php
/**
* Origami PDF Component
*
* based on code from:
* http://www.ros.co.nz/pdf
*
* A PHP class to provide the basic functionality to create a pdf document without
* any requirement for additional modules.
*
* @author		jas Osborne <busytoby@gmail.com>
* @version 	001
* @package	OrigamiPdf
*/
class OrigamiPdfComponent extends Object {

/**
* the current number of pdf objects in the document
*/
var $numObj=0;
/**
* this array contains all of the pdf objects, ready for final assembly
*/
var $objects = array();
/**
* the objectId (number within the objects array) of the document catalog
*/
var $catalogId;
/**
* 
*/
var $currentNode;
/**
* object number of the current page
*/
var $currentPage;
/**
* object number of the currently active contents block
*/
var $currentContents;
/**
* current colour for fill operations, defaults to inactive value, all three components should be between 0 and 1 inclusive when active
*/
var $currentColour=array('r'=>-1,'g'=>-1,'b'=>-1);
/**
* current colour for stroke operations (lines etc.)
*/
var $currentStrokeColour=array('r'=>-1,'g'=>-1,'b'=>-1);
/**
* current style that lines are drawn in
*/
var $currentLineStyle='';
/**
* an array which is used to save the state of the document, mainly the colours and styles
* it is used to temporarily change to another state, the change back to what it was before
*/
var $stateStack = array();
/**
* number of elements within the state stack
*/
var $nStateStack = 0;
/**
* number of page objects within the document
*/
var $numPages=0;
/**
* object Id storage stack
*/
var $stack=array();
/**
* number of elements within the object Id storage stack
*/
var $nStack=0;
/**
* an array which contains information about the objects which are not firmly attached to pages
* these have been added with the addObject function
*/
var $looseObjects=array();
/**
* array contains infomation about how the loose objects are to be added to the document
*/
var $addLooseObjects=array();
/**
* the objectId of the information object for the document
* this contains authorship, title etc.
*/
var $infoObject=0;
/**
* number of images being tracked within the document
*/
var $numImages=0;
/**
* an array containing options about the document
* it defaults to turning on the compression of the objects
*/
var $options=array('compression'=>1);
/**
* the objectId of the first page of the document
*/
var $firstPageId;
/**
* used to track the last used value of the inter-word spacing, this is so that it is known
* when the spacing is changed.
*/
var $wordSpaceAdjust=0;
/**
* the object Id of the procset object
*/
var $procsetObjectId;
/**
* messages are stored here during processing, these can be selected afterwards to give some useful debug information
*/
var $messages='';
/**
* the file identifier, used to uniquely identify a pdf document
*/
var $fileIdentifier='';
/**
* array which forms a stack to keep track of nested callback functions
*/
var $callback = array();
/**
* the number of callback functions in the callback array
*/
var $nCallback = 0;
/**
* store label->id pairs for named destinations, these will be used to replace internal links
* done this way so that destinations can be defined after the location that links to them
*/
var $destinations = array();
/**
* store the stack for the transaction commands, each item in here is a record of the values of all the 
* variables within the class, so that the user can rollback at will (from each 'start' command)
* note that this includes the objects array, so these can be large.
*/
var $checkpoint = '';
/**
* class constructor
* this will start a new document
* @var array array of 4 numbers, defining the bottom left and upper right corner of the page. first two are normally zero.
*/
function newDoc($pageSize=array(0,0,612,792)){
  $this->newDocument($pageSize);
}

/**
* Document object methods (internal use only)
*
* There is about one object method for each type of object in the pdf document
* Each function has the same call list ($id,$action,$options).
* $id = the object ID of the object, or what it is to be if it is being created
* $action = a string specifying the action to be performed, though ALL must support:
*           'new' - create the object with the id $id
*           'out' - produce the output for the pdf object
* $options = optional, a string or array containing the various parameters for the object
*
* These, in conjunction with the output function are the ONLY way for output to be produced 
* within the pdf 'file'.
*/

/**
*destination object, used to specify the location for the user to jump to, presently on opening
*/
function o_destination($id,$action,$options=''){
  if ($action!='new'){
    $o =& $this->objects[$id];
  }
  switch($action){
    case 'new':
      $this->objects[$id]=array('t'=>'destination','info'=>array());
      $tmp = '';
      switch ($options['type']){
        case 'XYZ':
        case 'FitR':
          $tmp =  ' '.$options['p3'].$tmp;
        case 'FitH':
        case 'FitV':
        case 'FitBH':
        case 'FitBV':
          $tmp =  ' '.$options['p1'].' '.$options['p2'].$tmp;
        case 'Fit':
        case 'FitB':
          $tmp =  $options['type'].$tmp;
          $this->objects[$id]['info']['string']=$tmp;
          $this->objects[$id]['info']['page']=$options['page'];
      }
      break;
    case 'out':
      $tmp = $o['info'];
      $res="\n".$id." 0 obj\n".'['.$tmp['page'].' 0 R /'.$tmp['string']."]\nendobj\n";
      return $res;
      break;
  }
}

/**
* set the viewer preferences
*/
function o_viewerPreferences($id,$action,$options=''){
  if ($action!='new'){
    $o =& $this->objects[$id];
  }
  switch ($action){
    case 'new':
      $this->objects[$id]=array('t'=>'viewerPreferences','info'=>array());
      break;
    case 'add':
      foreach($options as $k=>$v){
        switch ($k){
          case 'HideToolbar':
          case 'HideMenubar':
          case 'HideWindowUI':
          case 'FitWindow':
          case 'CenterWindow':
          case 'NonFullScreenPageMode':
          case 'Direction':
            $o['info'][$k]=$v;
          break;
        }
      }
      break;
    case 'out':

      $res="\n".$id." 0 obj\n".'<< ';
      foreach($o['info'] as $k=>$v){
        $res.="\n/".$k.' '.$v;
      }
      $res.="\n>>\n";
      return $res;
      break;
  }
}

/**
* define the document catalog, the overall controller for the document
*/
function o_catalog($id,$action,$options=''){
  if ($action!='new'){
    $o =& $this->objects[$id];
  }
  switch ($action){
    case 'new':
      $this->objects[$id]=array('t'=>'catalog','info'=>array());
      $this->catalogId=$id;
      break;
    case 'outlines':
    case 'pages':
    case 'openHere':
      $o['info'][$action]=$options;
      break;
    case 'viewerPreferences':
      if (!isset($o['info']['viewerPreferences'])){
        $this->numObj++;
        $this->o_viewerPreferences($this->numObj,'new');
        $o['info']['viewerPreferences']=$this->numObj;
      }
      $vp = $o['info']['viewerPreferences'];
      $this->o_viewerPreferences($vp,'add',$options);
      break;
    case 'out':
      $res="\n".$id." 0 obj\n".'<< /Type /Catalog';
      foreach($o['info'] as $k=>$v){
        switch($k){
          case 'outlines':
            $res.="\n".'/Outlines '.$v.' 0 R';
            break;
          case 'pages':
            $res.="\n".'/Pages '.$v.' 0 R';
            break;
          case 'viewerPreferences':
            $res.="\n".'/ViewerPreferences '.$o['info']['viewerPreferences'].' 0 R';
            break;
          case 'openHere':
            $res.="\n".'/OpenAction '.$o['info']['openHere'].' 0 R';
            break;
        }
      }
      $res.=" >>\nendobj";
      return $res;
      break;
  }
}

/**
* object which is a parent to the pages in the document
*/
function o_pages($id,$action,$options=''){
  if ($action!='new'){
    $o =& $this->objects[$id];
  }
  switch ($action){
    case 'new':
      $this->objects[$id]=array('t'=>'pages','info'=>array());
      $this->o_catalog($this->catalogId,'pages',$id);
      break;
    case 'page':
      if (!is_array($options)){
        // then it will just be the id of the new page
        $o['info']['pages'][]=$options;
      } else {
        // then it should be an array having 'id','rid','pos', where rid=the page to which this one will be placed relative
        // and pos is either 'before' or 'after', saying where this page will fit.
        if (isset($options['id']) && isset($options['rid']) && isset($options['pos'])){
          $i = array_search($options['rid'],$o['info']['pages']);
          if (isset($o['info']['pages'][$i]) && $o['info']['pages'][$i]==$options['rid']){
            // then there is a match
            // make a space
            switch ($options['pos']){
              case 'before':
                $k = $i;
                break;
              case 'after':
                $k=$i+1;
                break;
              default:
                $k=-1;
                break;
            }
            if ($k>=0){
              for ($j=count($o['info']['pages'])-1;$j>=$k;$j--){
                $o['info']['pages'][$j+1]=$o['info']['pages'][$j];
              }
              $o['info']['pages'][$k]=$options['id'];
            }
          }
        } 
      }
      break;
    case 'procset':
      $o['info']['procset']=$options;
      break;
    case 'mediaBox':
      $o['info']['mediaBox']=$options; // which should be an array of 4 numbers
      break;
    case 'xObject':
      $o['info']['xObjects'][]=array('objNum'=>$options['objNum'],'label'=>$options['label']);
      break;
    case 'out':
      if (count($o['info']['pages'])){
        $res="\n".$id." 0 obj\n<< /Type /Pages\n/Kids [";
        foreach($o['info']['pages'] as $k=>$v){
          $res.=$v." 0 R\n";
        }
        $res.="]\n/Count ".count($this->objects[$id]['info']['pages']);
        if (isset($o['info']['procset'])){
          $res.="\n/Resources <<";
          if (isset($o['info']['procset'])){
            $res.="\n/ProcSet ".$o['info']['procset']." 0 R";
          }
          if (isset($o['info']['xObjects']) && count($o['info']['xObjects'])){
            $res.="\n/XObject << ";
            foreach($o['info']['xObjects'] as $finfo){
              $res.="\n/".$finfo['label']." ".$finfo['objNum']." 0 R";
            }
            $res.=" >>";
          }
          $res.="\n>>";
          if (isset($o['info']['mediaBox'])){
            $tmp=$o['info']['mediaBox'];
            $res.="\n/MediaBox [".sprintf('%.3f',$tmp[0]).' '.sprintf('%.3f',$tmp[1]).' '.sprintf('%.3f',$tmp[2]).' '.sprintf('%.3f',$tmp[3]).']';
          }
        }
        $res.="\n >>\nendobj";
      } else {
        $res="\n".$id." 0 obj\n<< /Type /Pages\n/Count 0\n>>\nendobj";
      }
      return $res;
    break;
  }
}

/**
* define the outlines in the doc, empty for now
*/
function o_outlines($id,$action,$options=''){
  if ($action!='new'){
    $o =& $this->objects[$id];
  }
  switch ($action){
    case 'new':
      $this->objects[$id]=array('t'=>'outlines','info'=>array('outlines'=>array()));
      $this->o_catalog($this->catalogId,'outlines',$id);
      break;
    case 'outline':
      $o['info']['outlines'][]=$options;
      break;
    case 'out':
      if (count($o['info']['outlines'])){
        $res="\n".$id." 0 obj\n<< /Type /Outlines /Kids [";
        foreach($o['info']['outlines'] as $k=>$v){
          $res.=$v." 0 R ";
        }
        $res.="] /Count ".count($o['info']['outlines'])." >>\nendobj";
      } else {
        $res="\n".$id." 0 obj\n<< /Type /Outlines /Count 0 >>\nendobj";
      }
      return $res;
      break;
  }
}

/**
* the document procset, solves some problems with printing to old PS printers
*/
function o_procset($id,$action,$options=''){
  if ($action!='new'){
    $o =& $this->objects[$id];
  }
  switch ($action){
    case 'new':
      $this->objects[$id]=array('t'=>'procset','info'=>array('PDF'=>1,'Text'=>1));
      $this->o_pages($this->currentNode,'procset',$id);
      $this->procsetObjectId=$id;
      break;
    case 'add':
      // this is to add new items to the procset list, despite the fact that this is considered
      // obselete, the items are required for printing to some postscript printers
      switch ($options) {
        case 'ImageB':
        case 'ImageC':
        case 'ImageI':
          $o['info'][$options]=1;
          break;
      }
      break;
    case 'out':
      $res="\n".$id." 0 obj\n[";
      foreach ($o['info'] as $label=>$val){
        $res.='/'.$label.' ';
      }
      $res.="]\nendobj";
      return $res;
      break;
  }
}

/**
* define the document information
*/
function o_info($id,$action,$options=''){
  if ($action!='new'){
    $o =& $this->objects[$id];
  }
  switch ($action){
    case 'new':
      $this->infoObject=$id;
      $date='D:'.date('Ymd');
      $this->objects[$id]=array('t'=>'info','info'=>array('Creator'=>'EAS Technologies pdf writer, http://www.clearmyrecord.com','CreationDate'=>$date));
      break;
    case 'Title':
    case 'Author':
    case 'Subject':
    case 'Keywords':
    case 'Creator':
    case 'Producer':
    case 'CreationDate':
    case 'ModDate':
    case 'Trapped':
      $o['info'][$action]=$options;
      break;
    case 'out':
      $res="\n".$id." 0 obj\n<<\n";
      foreach ($o['info']  as $k=>$v){
        $res.='/'.$k.' (';
        $res.=$this->filterText($v);
        $res.=")\n";
      }
      $res.=">>\nendobj";
      return $res;
      break;
  }
}

/**
* an action object, used to link to URLS initially
*/
function o_action($id,$action,$options=''){
  if ($action!='new'){
    $o =& $this->objects[$id];
  }
  switch ($action){
    case 'new':
      if (is_array($options)){
        $this->objects[$id]=array('t'=>'action','info'=>$options,'type'=>$options['type']);
      } else {
        // then assume a URI action
        $this->objects[$id]=array('t'=>'action','info'=>$options,'type'=>'URI');
      }
      break;
    case 'out':
      $res="\n".$id." 0 obj\n<< /Type /Action";
      switch($o['type']){
        case 'ilink':
          // there will be an 'label' setting, this is the name of the destination
          $res.="\n/S /GoTo\n/D ".$this->destinations[(string)$o['info']['label']]." 0 R";
          break;
        case 'URI':
          $res.="\n/S /URI\n/URI (";
          $res.=$this->filterText($o['info']);
          $res.=")";
          break;
      }
      $res.="\n>>\nendobj";
      return $res;
      break;
  }
}

/**
* an annotation object, this will add an annotation to the current page.
* initially will support just link annotations 
*/
function o_annotation($id,$action,$options=''){
  if ($action!='new'){
    $o =& $this->objects[$id];
  }
  switch ($action){
    case 'new':
      // add the annotation to the current page
      $pageId = $this->currentPage;
      $this->o_page($pageId,'annot',$id);
      // and add the action object which is going to be required
      switch($options['type']){
        case 'link':
          $this->objects[$id]=array('t'=>'annotation','info'=>$options);
          $this->numObj++;
          $this->o_action($this->numObj,'new',$options['url']);
          $this->objects[$id]['info']['actionId']=$this->numObj;
          break;
        case 'ilink':
          // this is to a named internal link
          $label = $options['label'];
          $this->objects[$id]=array('t'=>'annotation','info'=>$options);
          $this->numObj++;
          $this->o_action($this->numObj,'new',array('type'=>'ilink','label'=>$label));
          $this->objects[$id]['info']['actionId']=$this->numObj;
          break;
      }
      break;
    case 'out':
      $res="\n".$id." 0 obj\n<< /Type /Annot";
      switch($o['info']['type']){
        case 'link':
        case 'ilink':
          $res.= "\n/Subtype /Link";
          break;
      }
      $res.="\n/A ".$o['info']['actionId']." 0 R";
      $res.="\n/Border [0 0 0]";
      $res.="\n/H /I";
      $res.="\n/Rect [ ";
      foreach($o['info']['rect'] as $v){
        $res.= sprintf("%.4f ",$v);
      }
      $res.="]";
      $res.="\n>>\nendobj";
      return $res;
      break;
  }
}

/**
* a page object, it also creates a contents object to hold its contents
*/
function o_page($id,$action,$options=''){
  if ($action!='new'){
    $o =& $this->objects[$id];
  }
  switch ($action){
    case 'new':
      $this->numPages++;
      $this->objects[$id]=array('t'=>'page','info'=>array('parent'=>$this->currentNode,'pageNum'=>$this->numPages));
      if (is_array($options)){
        // then this must be a page insertion, array shoudl contain 'rid','pos'=[before|after]
        $options['id']=$id;
        $this->o_pages($this->currentNode,'page',$options);
      } else {
        $this->o_pages($this->currentNode,'page',$id);
      }
      $this->currentPage=$id;
      //make a contents object to go with this page
      $this->numObj++;
      $this->o_contents($this->numObj,'new',$id);
      $this->currentContents=$this->numObj;
      $this->objects[$id]['info']['contents']=array();
      $this->objects[$id]['info']['contents'][]=$this->numObj;
      $match = ($this->numPages%2 ? 'odd' : 'even');
      foreach($this->addLooseObjects as $oId=>$target){
        if ($target=='all' || $match==$target){
          $this->objects[$id]['info']['contents'][]=$oId;
        }
      }
      break;
    case 'content':
      $o['info']['contents'][]=$options;
      break;
    case 'annot':
      // add an annotation to this page
      if (!isset($o['info']['annot'])){
        $o['info']['annot']=array();
      }
      // $options should contain the id of the annotation dictionary
      $o['info']['annot'][]=$options;
      break;
    case 'out':
      $res="\n".$id." 0 obj\n<< /Type /Page";
      $res.="\n/Parent ".$o['info']['parent']." 0 R";
      if (isset($o['info']['annot'])){
        $res.="\n/Annots [";
        foreach($o['info']['annot'] as $aId){
          $res.=" ".$aId." 0 R";
        }
        $res.=" ]";
      }
      $count = count($o['info']['contents']);
      if ($count==1){
        $res.="\n/Contents ".$o['info']['contents'][0]." 0 R";
      } else if ($count>1){
        $res.="\n/Contents [\n";
        foreach ($o['info']['contents'] as $cId){
          $res.=$cId." 0 R\n";
        }
        $res.="]";
      }
      $res.="\n>>\nendobj";
      return $res;
      break;
  }
}

/**
* the contents objects hold all of the content which appears on pages
*/
function o_contents($id,$action,$options=''){
  if ($action!='new'){
    $o =& $this->objects[$id];
  }
  switch ($action){
    case 'new':
      $this->objects[$id]=array('t'=>'contents','c'=>'','info'=>array());
      if (strlen($options) && intval($options)){
        // then this contents is the primary for a page
        $this->objects[$id]['onPage']=$options;
      } else if ($options=='raw'){
        // then this page contains some other type of system object
        $this->objects[$id]['raw']=1;
      }
      break;
    case 'add':
      // add more options to the decleration
      foreach ($options as $k=>$v){
        $o['info'][$k]=$v;
      }
    case 'out':
      $tmp=$o['c'];
      $res= "\n".$id." 0 obj\n";
      if (isset($this->objects[$id]['raw'])){
        $res.=$tmp;
      } else {
        $res.= "<<";
        if (function_exists('gzcompress') && $this->options['compression']){
          // then implement ZLIB based compression on this content stream
          $res.=" /Filter /FlateDecode";
          $tmp = gzcompress($tmp);
        }
        foreach($o['info'] as $k=>$v){
          $res .= "\n/".$k.' '.$v;
        }
        $res.="\n/Length ".strlen($tmp)." >>\nstream\n".$tmp."\nendstream";
      }
      $res.="\nendobj\n";
      return $res;
      break;
  }
}

/**
* an image object, will be an XObject in the document, includes description and data
*/
function o_image($id,$action,$options=''){
  if ($action!='new'){
    $o =& $this->objects[$id];
  }
  switch($action){
    case 'new':
      // make the new object
      $this->objects[$id]=array('t'=>'image','data'=>$options['data'],'info'=>array());
      $this->objects[$id]['info']['Type']='/XObject';
      $this->objects[$id]['info']['Subtype']='/Image';
      $this->objects[$id]['info']['Width']=$options['iw'];
      $this->objects[$id]['info']['Height']=$options['ih'];
      if (!isset($options['type']) || $options['type']=='jpg'){
        if (!isset($options['channels'])){
          $options['channels']=3;
        }
        switch($options['channels']){
          case 1:
            $this->objects[$id]['info']['ColorSpace']='/DeviceGray';
            break;
          default:
            $this->objects[$id]['info']['ColorSpace']='/DeviceRGB';
            break;
        }
        $this->objects[$id]['info']['Filter']='/DCTDecode';
        $this->objects[$id]['info']['BitsPerComponent']=8;
      } else if ($options['type']=='png'){
        $this->objects[$id]['info']['Filter']='/FlateDecode';
        $this->objects[$id]['info']['DecodeParms']='<< /Predictor 15 /Colors '.$options['ncolor'].' /Columns '.$options['iw'].' /BitsPerComponent '.$options['bitsPerComponent'].'>>';
        if (strlen($options['pdata'])){
          $tmp = ' [ /Indexed /DeviceRGB '.(strlen($options['pdata'])/3-1).' ';
          $this->numObj++;
          $this->o_contents($this->numObj,'new');
          $this->objects[$this->numObj]['c']=$options['pdata'];
          $tmp.=$this->numObj.' 0 R';
          $tmp .=' ]';
          $this->objects[$id]['info']['ColorSpace'] = $tmp;
          if (isset($options['transparency'])){
            switch($options['transparency']['type']){
              case 'indexed':
                $tmp=' [ '.$options['transparency']['data'].' '.$options['transparency']['data'].'] ';
                $this->objects[$id]['info']['Mask'] = $tmp;
                break;
            }
          }
        } else {
          $this->objects[$id]['info']['ColorSpace']='/'.$options['color'];
        }
        $this->objects[$id]['info']['BitsPerComponent']=$options['bitsPerComponent'];
      }
      // assign it a place in the named resource dictionary as an external object, according to
      // the label passed in with it.
      $this->o_pages($this->currentNode,'xObject',array('label'=>$options['label'],'objNum'=>$id));
      // also make sure that we have the right procset object for it.
      $this->o_procset($this->procsetObjectId,'add','ImageC');
      break;
    case 'out':
      $tmp=$o['data'];
      $res= "\n".$id." 0 obj\n<<";
      foreach($o['info'] as $k=>$v){
        $res.="\n/".$k.' '.$v;
      }
      $res.="\n/Length ".strlen($tmp)." >>\nstream\n".$tmp."\nendstream\nendobj\n";
      return $res;
      break;
  }
}

/**
* calculate the 16 byte version of the 128 bit md5 digest of the string
*/
function md5_16($string){
  $tmp = md5($string);
  $out='';
  for ($i=0;$i<=30;$i=$i+2){
    $out.=chr(hexdec(substr($tmp,$i,2)));
  }
  return $out;
}

/**
* should be used for internal checks, not implemented as yet
*/
function checkAllHere(){
}

/**
* return the pdf stream as a string returned from the function
*/
function output($debug=0){

  if ($debug){
    // turn compression off
    $this->options['compression']=0;
  }

  $this->checkAllHere();

  $xref=array();
  $content="%PDF-1.3\n%âãÏÓ\n";
//  $content="%PDF-1.3\n";
  $pos=strlen($content);
  foreach($this->objects as $k=>$v){
    $tmp='o_'.$v['t'];
    $cont=$this->$tmp($k,'out');
    $content.=$cont;
    $xref[]=$pos;
    $pos+=strlen($cont);
  }
  $content.="\nxref\n0 ".(count($xref)+1)."\n0000000000 65535 f \n";
  foreach($xref as $p){
    $content.=substr('0000000000',0,10-strlen($p)).$p." 00000 n \n";
  }
  $content.="\ntrailer\n  << /Size ".(count($xref)+1)."\n     /Root 1 0 R\n     /Info ".$this->infoObject." 0 R\n";
  if (strlen($this->fileIdentifier)){
    $content .= "/ID[<".$this->fileIdentifier."><".$this->fileIdentifier.">]\n";
  }
  $content .= "  >>\nstartxref\n".$pos."\n%%EOF\n";
  return $content;
}

/**
* intialize a new document
* if this is called on an existing document results may be unpredictable, but the existing document would be lost at minimum
* this function is called automatically by the constructor function
*
* @access private
*/
function newDocument($pageSize=array(0,0,612,792)){
  $this->numObj=0;
  $this->objects = array();

  $this->numObj++;
  $this->o_catalog($this->numObj,'new');

  $this->numObj++;
  $this->o_outlines($this->numObj,'new');

  $this->numObj++;
  $this->o_pages($this->numObj,'new');

  $this->o_pages($this->numObj,'mediaBox',$pageSize);
  $this->currentNode = 3;

  $this->numObj++;
  $this->o_procset($this->numObj,'new');

  $this->numObj++;
  $this->o_info($this->numObj,'new');

  $this->numObj++;
  $this->o_page($this->numObj,'new');

  // need to store the first page id as there is no way to get it to the user during 
  // startup
  $this->firstPageId = $this->currentContents;
}

/**
* function for the user to find out what the ID is of the first page that was created during
* startup - useful if they wish to add something to it later.
*/
function getFirstPageId(){
  return $this->firstPageId;
}

/**
* add content to the currently active object
*
* @access private
*/
function addContent($content){
  $this->objects[$this->currentContents]['c'].=$content;
}

/**
* sets the colour for fill operations
*/
function setColor($r,$g,$b,$force=0){
  if ($r>=0 && ($force || $r!=$this->currentColour['r'] || $g!=$this->currentColour['g'] || $b!=$this->currentColour['b'])){
    $this->objects[$this->currentContents]['c'].="\n".sprintf('%.3f',$r).' '.sprintf('%.3f',$g).' '.sprintf('%.3f',$b).' rg';
    $this->currentColour=array('r'=>$r,'g'=>$g,'b'=>$b);
  }
}

/**
* sets the colour for stroke operations
*/
function setStrokeColor($r,$g,$b,$force=0){
  if ($r>=0 && ($force || $r!=$this->currentStrokeColour['r'] || $g!=$this->currentStrokeColour['g'] || $b!=$this->currentStrokeColour['b'])){
    $this->objects[$this->currentContents]['c'].="\n".sprintf('%.3f',$r).' '.sprintf('%.3f',$g).' '.sprintf('%.3f',$b).' RG';
    $this->currentStrokeColour=array('r'=>$r,'g'=>$g,'b'=>$b);
  }
}

/**
* draw a line from one set of coordinates to another
*/
function line($x1,$y1,$x2,$y2){
  $this->objects[$this->currentContents]['c'].="\n".sprintf('%.3f',$x1).' '.sprintf('%.3f',$y1).' m '.sprintf('%.3f',$x2).' '.sprintf('%.3f',$y2).' l S';
}

/**
* draw a bezier curve based on 4 control points
*/
function curve($x0,$y0,$x1,$y1,$x2,$y2,$x3,$y3){
  // in the current line style, draw a bezier curve from (x0,y0) to (x3,y3) using the other two points
  // as the control points for the curve.
  $this->objects[$this->currentContents]['c'].="\n".sprintf('%.3f',$x0).' '.sprintf('%.3f',$y0).' m '.sprintf('%.3f',$x1).' '.sprintf('%.3f',$y1);
  $this->objects[$this->currentContents]['c'].= ' '.sprintf('%.3f',$x2).' '.sprintf('%.3f',$y2).' '.sprintf('%.3f',$x3).' '.sprintf('%.3f',$y3).' c S';
}

/**
* draw a part of an ellipse
*/
function partEllipse($x0,$y0,$astart,$afinish,$r1,$r2=0,$angle=0,$nSeg=8){
  $this->ellipse($x0,$y0,$r1,$r2,$angle,$nSeg,$astart,$afinish,0);
}

/**
* draw a filled ellipse
*/
function filledEllipse($x0,$y0,$r1,$r2=0,$angle=0,$nSeg=8,$astart=0,$afinish=360){
  return $this->ellipse($x0,$y0,$r1,$r2=0,$angle,$nSeg,$astart,$afinish,1,1);
}

/**
* draw an ellipse
* note that the part and filled ellipse are just special cases of this function
*
* draws an ellipse in the current line style
* centered at $x0,$y0, radii $r1,$r2
* if $r2 is not set, then a circle is drawn
* nSeg is not allowed to be less than 2, as this will simply draw a line (and will even draw a 
* pretty crappy shape at 2, as we are approximating with bezier curves.
*/
function ellipse($x0,$y0,$r1,$r2=0,$angle=0,$nSeg=8,$astart=0,$afinish=360,$close=1,$fill=0){
  if ($r1==0){
    return;
  }
  if ($r2==0){
    $r2=$r1;
  }
  if ($nSeg<2){
    $nSeg=2;
  }

  $astart = deg2rad((float)$astart);
  $afinish = deg2rad((float)$afinish);
  $totalAngle =$afinish-$astart;

  $dt = $totalAngle/$nSeg;
  $dtm = $dt/3;

  if ($angle != 0){
    $a = -1*deg2rad((float)$angle);
    $tmp = "\n q ";
    $tmp .= sprintf('%.3f',cos($a)).' '.sprintf('%.3f',(-1.0*sin($a))).' '.sprintf('%.3f',sin($a)).' '.sprintf('%.3f',cos($a)).' ';
    $tmp .= sprintf('%.3f',$x0).' '.sprintf('%.3f',$y0).' cm';
    $this->objects[$this->currentContents]['c'].= $tmp;
    $x0=0;
    $y0=0;
  }

  $t1 = $astart;
  $a0 = $x0+$r1*cos($t1);
  $b0 = $y0+$r2*sin($t1);
  $c0 = -$r1*sin($t1);
  $d0 = $r2*cos($t1);

  $this->objects[$this->currentContents]['c'].="\n".sprintf('%.3f',$a0).' '.sprintf('%.3f',$b0).' m ';
  for ($i=1;$i<=$nSeg;$i++){
    // draw this bit of the total curve
    $t1 = $i*$dt+$astart;
    $a1 = $x0+$r1*cos($t1);
    $b1 = $y0+$r2*sin($t1);
    $c1 = -$r1*sin($t1);
    $d1 = $r2*cos($t1);
    $this->objects[$this->currentContents]['c'].="\n".sprintf('%.3f',($a0+$c0*$dtm)).' '.sprintf('%.3f',($b0+$d0*$dtm));
    $this->objects[$this->currentContents]['c'].= ' '.sprintf('%.3f',($a1-$c1*$dtm)).' '.sprintf('%.3f',($b1-$d1*$dtm)).' '.sprintf('%.3f',$a1).' '.sprintf('%.3f',$b1).' c';
    $a0=$a1;
    $b0=$b1;
    $c0=$c1;
    $d0=$d1;    
  }
  if ($fill){
    $this->objects[$this->currentContents]['c'].=' f';
  } else {
    if ($close){
      $this->objects[$this->currentContents]['c'].=' s'; // small 's' signifies closing the path as well
    } else {
      $this->objects[$this->currentContents]['c'].=' S';
    }
  }
  if ($angle !=0){
    $this->objects[$this->currentContents]['c'].=' Q';
  }
}

/**
* this sets the line drawing style.
* width, is the thickness of the line in user units
* cap is the type of cap to put on the line, values can be 'butt','round','square'
*    where the diffference between 'square' and 'butt' is that 'square' projects a flat end past the
*    end of the line.
* join can be 'miter', 'round', 'bevel'
* dash is an array which sets the dash pattern, is a series of length values, which are the lengths of the
*   on and off dashes.
*   (2) represents 2 on, 2 off, 2 on , 2 off ...
*   (2,1) is 2 on, 1 off, 2 on, 1 off.. etc
* phase is a modifier on the dash pattern which is used to shift the point at which the pattern starts. 
*/
function setLineStyle($width=1,$cap='',$join='',$dash='',$phase=0){

  // this is quite inefficient in that it sets all the parameters whenever 1 is changed, but will fix another day
  $string = '';
  if ($width>0){
    $string.= $width.' w';
  }
  $ca = array('butt'=>0,'round'=>1,'square'=>2);
  if (isset($ca[$cap])){
    $string.= ' '.$ca[$cap].' J';
  }
  $ja = array('miter'=>0,'round'=>1,'bevel'=>2);
  if (isset($ja[$join])){
    $string.= ' '.$ja[$join].' j';
  }
  if (is_array($dash)){
    $string.= ' [';
    foreach ($dash as $len){
      $string.=' '.$len;
    }
    $string.= ' ] '.$phase.' d';
  }
  $this->currentLineStyle = $string;
  $this->objects[$this->currentContents]['c'].="\n".$string;
}

/**
* draw a polygon, the syntax for this is similar to the GD polygon command
*/
function polygon($p,$np,$f=0){
  $this->objects[$this->currentContents]['c'].="\n";
  $this->objects[$this->currentContents]['c'].=sprintf('%.3f',$p[0]).' '.sprintf('%.3f',$p[1]).' m ';
  for ($i=2;$i<$np*2;$i=$i+2){
    $this->objects[$this->currentContents]['c'].= sprintf('%.3f',$p[$i]).' '.sprintf('%.3f',$p[$i+1]).' l ';
  }
  if ($f==1){
    $this->objects[$this->currentContents]['c'].=' f';
  } else {
    $this->objects[$this->currentContents]['c'].=' S';
  }
}

/**
* a filled rectangle, note that it is the width and height of the rectangle which are the secondary paramaters, not
* the coordinates of the upper-right corner
*/
function filledRectangle($x1,$y1,$width,$height){
  $this->objects[$this->currentContents]['c'].="\n".sprintf('%.3f',$x1).' '.sprintf('%.3f',$y1).' '.sprintf('%.3f',$width).' '.sprintf('%.3f',$height).' re f';
}

/**
* draw a rectangle, note that it is the width and height of the rectangle which are the secondary paramaters, not
* the coordinates of the upper-right corner
*/
function rectangle($x1,$y1,$width,$height){
  $this->objects[$this->currentContents]['c'].="\n".sprintf('%.3f',$x1).' '.sprintf('%.3f',$y1).' '.sprintf('%.3f',$width).' '.sprintf('%.3f',$height).' re S';
}

/**
* add a new page to the document
* this also makes the new page the current active object
*/
function newPage($insert=0,$id=0,$pos='after'){

  // if there is a state saved, then go up the stack closing them
  // then on the new page, re-open them with the right setings
  
  if ($this->nStateStack){
    for ($i=$this->nStateStack;$i>=1;$i--){
      $this->restoreState($i);
    }
  }

  $this->numObj++;
  if ($insert){
    // the id from the ezPdf class is the od of the contents of the page, not the page object itself
    // query that object to find the parent
    $rid = $this->objects[$id]['onPage'];
    $opt= array('rid'=>$rid,'pos'=>$pos);
    $this->o_page($this->numObj,'new',$opt);
  } else {
    $this->o_page($this->numObj,'new');
  }
  // if there is a stack saved, then put that onto the page
  if ($this->nStateStack){
    for ($i=1;$i<=$this->nStateStack;$i++){
      $this->saveState($i);
    }
  }  
  // and if there has been a stroke or fill colour set, then transfer them
  if ($this->currentColour['r']>=0){
    $this->setColor($this->currentColour['r'],$this->currentColour['g'],$this->currentColour['b'],1);
  }
  if ($this->currentStrokeColour['r']>=0){
    $this->setStrokeColor($this->currentStrokeColour['r'],$this->currentStrokeColour['g'],$this->currentStrokeColour['b'],1);
  }

  // if there is a line style set, then put this in too
  if (strlen($this->currentLineStyle)){
    $this->objects[$this->currentContents]['c'].="\n".$this->currentLineStyle;
  }

  // the call to the o_page object set currentContents to the present page, so this can be returned as the page id
  return $this->currentContents;
}

/**
* output the pdf code, streaming it to the browser
* the relevant headers are set so that hopefully the browser will recognise it
*/
function stream($options=''){
  // setting the options allows the adjustment of the headers
  // values at the moment are:
  // 'Content-Disposition'=>'filename'  - sets the filename, though not too sure how well this will 
  //        work as in my trial the browser seems to use the filename of the php file with .pdf on the end
  // 'Accept-Ranges'=>1 or 0 - if this is not set to 1, then this header is not included, off by default
  //    this header seems to have caused some problems despite tha fact that it is supposed to solve
  //    them, so I am leaving it off by default.
  // 'compress'=> 1 or 0 - apply content stream compression, this is on (1) by default
  if (!is_array($options)){
    $options=array();
  }
  if ( isset($options['compress']) && $options['compress']==0){
    $tmp = $this->output(1);
  } else {
    $tmp = $this->output();
  }
  header("Content-type: application/pdf");
  header("Content-Length: ".strlen(ltrim($tmp)));
  $fileName = (isset($options['Content-Disposition'])?$options['Content-Disposition']:'file.pdf');
  header("Content-Disposition: inline; filename=".$fileName);
  if (isset($options['Accept-Ranges']) && $options['Accept-Ranges']==1){
    header("Accept-Ranges: ".strlen(ltrim($tmp))); 
  }
  echo ltrim($tmp);
}

/**
* filter the text, this is applied to all text just before being inserted into the pdf document
* it escapes the various things that need to be escaped, and so on
*
* @access private
*/
function filterText($text){
  $text = str_replace('\\','\\\\',$text);
  $text = str_replace('(','\(',$text);
  $text = str_replace(')','\)',$text);
  $text = str_replace('&lt;','<',$text);
  $text = str_replace('&gt;','>',$text);
  $text = str_replace('&#039;','\'',$text);
  $text = str_replace('&quot;','"',$text);
  $text = str_replace('&amp;','&',$text);

  return $text;
}

/**
* this will be called at a new page to return the state to what it was on the 
* end of the previous page, before the stack was closed down
* This is to get around not being able to have open 'q' across pages
*
*/
function saveState($pageEnd=0){
  if ($pageEnd){
    // this will be called at a new page to return the state to what it was on the 
    // end of the previous page, before the stack was closed down
    // This is to get around not being able to have open 'q' across pages
    $opt = $this->stateStack[$pageEnd]; // ok to use this as stack starts numbering at 1
    $this->setColor($opt['col']['r'],$opt['col']['g'],$opt['col']['b'],1);
    $this->setStrokeColor($opt['str']['r'],$opt['str']['g'],$opt['str']['b'],1);
    $this->objects[$this->currentContents]['c'].="\n".$opt['lin'];
//    $this->currentLineStyle = $opt['lin'];
  } else {
    $this->nStateStack++;
    $this->stateStack[$this->nStateStack]=array(
      'col'=>$this->currentColour
     ,'str'=>$this->currentStrokeColour
     ,'lin'=>$this->currentLineStyle
    );
  }
  $this->objects[$this->currentContents]['c'].="\nq";
}

/**
* restore a previously saved state
*/
function restoreState($pageEnd=0){
  if (!$pageEnd){
    $n = $this->nStateStack;
    $this->currentColour = $this->stateStack[$n]['col'];
    $this->currentStrokeColour = $this->stateStack[$n]['str'];
    $this->objects[$this->currentContents]['c'].="\n".$this->stateStack[$n]['lin'];
    $this->currentLineStyle = $this->stateStack[$n]['lin'];
    unset($this->stateStack[$n]);
    $this->nStateStack--;
  }
  $this->objects[$this->currentContents]['c'].="\nQ";
}

/**
* make a loose object, the output will go into this object, until it is closed, then will revert to
* the current one.
* this object will not appear until it is included within a page.
* the function will return the object number
*/
function openObject(){
  $this->nStack++;
  $this->stack[$this->nStack]=array('c'=>$this->currentContents,'p'=>$this->currentPage);
  // add a new object of the content type, to hold the data flow
  $this->numObj++;
  $this->o_contents($this->numObj,'new');
  $this->currentContents=$this->numObj;
  $this->looseObjects[$this->numObj]=1;
  
  return $this->numObj;
}

/**
* open an existing object for editing
*/
function reopenObject($id){
   $this->nStack++;
   $this->stack[$this->nStack]=array('c'=>$this->currentContents,'p'=>$this->currentPage);
   $this->currentContents=$id;
   // also if this object is the primary contents for a page, then set the current page to its parent
   if (isset($this->objects[$id]['onPage'])){
     $this->currentPage = $this->objects[$id]['onPage'];
   }
}

/**
* close an object
*/
function closeObject(){
  // close the object, as long as there was one open in the first place, which will be indicated by
  // an objectId on the stack.
  if ($this->nStack>0){
    $this->currentContents=$this->stack[$this->nStack]['c'];
    $this->currentPage=$this->stack[$this->nStack]['p'];
    $this->nStack--;
    // easier to probably not worry about removing the old entries, they will be overwritten
    // if there are new ones.
  }
}

/**
* stop an object from appearing on pages from this point on
*/
function stopObject($id){
  // if an object has been appearing on pages up to now, then stop it, this page will
  // be the last one that could contian it.
  if (isset($this->addLooseObjects[$id])){
    $this->addLooseObjects[$id]='';
  }
}

/**
* after an object has been created, it wil only show if it has been added, using this function.
*/
function addObject($id,$options='add'){
  // add the specified object to the page
  if (isset($this->looseObjects[$id]) && $this->currentContents!=$id){
    // then it is a valid object, and it is not being added to itself
    switch($options){
      case 'all':
        // then this object is to be added to this page (done in the next block) and 
        // all future new pages. 
        $this->addLooseObjects[$id]='all';
      case 'add':
        if (isset($this->objects[$this->currentContents]['onPage'])){
          // then the destination contents is the primary for the page
          // (though this object is actually added to that page)
          $this->o_page($this->objects[$this->currentContents]['onPage'],'content',$id);
        }
        break;
      case 'even':
        $this->addLooseObjects[$id]='even';
        $pageObjectId=$this->objects[$this->currentContents]['onPage'];
        if ($this->objects[$pageObjectId]['info']['pageNum']%2==0){
          $this->addObject($id); // hacky huh :)
        }
        break;
      case 'odd':
        $this->addLooseObjects[$id]='odd';
        $pageObjectId=$this->objects[$this->currentContents]['onPage'];
        if ($this->objects[$pageObjectId]['info']['pageNum']%2==1){
          $this->addObject($id); // hacky huh :)
        }
        break;
      case 'next':
        $this->addLooseObjects[$id]='all';
        break;
      case 'nexteven':
        $this->addLooseObjects[$id]='even';
        break;
      case 'nextodd':
        $this->addLooseObjects[$id]='odd';
        break;
    }
  }
}

/**
* add content to the documents info object
*/
function addInfo($label,$value=0){
  // this will only work if the label is one of the valid ones.
  // modify this so that arrays can be passed as well.
  // if $label is an array then assume that it is key=>value pairs
  // else assume that they are both scalar, anything else will probably error
  if (is_array($label)){
    foreach ($label as $l=>$v){
      $this->o_info($this->infoObject,$l,$v);
    }
  } else {
    $this->o_info($this->infoObject,$label,$value);
  }
}

/**
* set the viewer preferences of the document, it is up to the browser to obey these.
*/
function setPreferences($label,$value=0){
  // this will only work if the label is one of the valid ones.
  if (is_array($label)){
    foreach ($label as $l=>$v){
      $this->o_catalog($this->catalogId,'viewerPreferences',array($l=>$v));
    }
  } else {
    $this->o_catalog($this->catalogId,'viewerPreferences',array($label=>$value));
  }
}

/**
* extract an integer from a position in a byte stream
*
* @access private
*/
function PRVT_getBytes(&$data,$pos,$num){
  // return the integer represented by $num bytes from $pos within $data
  $ret=0;
  for ($i=0;$i<$num;$i++){
    $ret=$ret*256;
    $ret+=ord($data[$pos+$i]);
  }
  return $ret;
}

/**
* add a PNG image into the document
* this should work with remote files
*/
function addPng($imgData,$x=0,$y=0,$w=0,$h=0){
  // read in a png file, interpret it, then add to the system
  $error=0;
  $tmp = get_magic_quotes_runtime();
  set_magic_quotes_runtime(0);

  $header = chr(137).chr(80).chr(78).chr(71).chr(13).chr(10).chr(26).chr(10);
  if (substr($imgData,0,8)!=$header){
    $error=1;
    $errormsg = 'this file does not have a valid header';
  }

  if (!$error){
    // set pointer
    $p = 8;
    $len = strlen($imgData);
    // cycle through the file, identifying chunks
    $haveHeader=0;
    $info=array();
    $idata='';
    $pdata='';
    while ($p<$len){
      $chunkLen = $this->PRVT_getBytes($imgData,$p,4);
      $chunkType = substr($imgData,$p+4,4);
//      echo $chunkType.' - '.$chunkLen.'<br>';
    
      switch($chunkType){
        case 'IHDR':
          // this is where all the file information comes from
          $info['width']=$this->PRVT_getBytes($imgData,$p+8,4);
          $info['height']=$this->PRVT_getBytes($imgData,$p+12,4);
          $info['bitDepth']=ord($imgData[$p+16]);
          $info['colorType']=ord($imgData[$p+17]);
          $info['compressionMethod']=ord($imgData[$p+18]);
          $info['filterMethod']=ord($imgData[$p+19]);
          $info['interlaceMethod']=ord($imgData[$p+20]);
//print_r($info);
          $haveHeader=1;
          if ($info['compressionMethod']!=0){
            $error=1;
            $errormsg = 'unsupported compression method';
          }
          if ($info['filterMethod']!=0){
            $error=1;
            $errormsg = 'unsupported filter method';
          }
          break;
        case 'PLTE':
          $pdata.=substr($imgData,$p+8,$chunkLen);
          break;
        case 'IDAT':
          $idata.=substr($imgData,$p+8,$chunkLen);
          break;
        case 'tRNS': 
          //this chunk can only occur once and it must occur after the PLTE chunk and before IDAT chunk 
          //print "tRNS found, color type = ".$info['colorType']."<BR>"; 
          $transparency = array();
          if ($info['colorType'] == 3) { // indexed color, rbg 
          /* corresponding to entries in the plte chunk 
          Alpha for palette index 0: 1 byte 
          Alpha for palette index 1: 1 byte 
          ...etc... 
          */ 
            // there will be one entry for each palette entry. up until the last non-opaque entry.
            // set up an array, stretching over all palette entries which will be o (opaque) or 1 (transparent)
            $transparency['type']='indexed';
            $numPalette = strlen($pdata)/3;
            $trans=0;
            for ($i=$chunkLen;$i>=0;$i--){
              if (ord($imgData[$p+8+$i])==0){
                $trans=$i;
              }
            }
            $transparency['data'] = $trans;
            
          } elseif($info['colorType'] == 0) { // grayscale 
          /* corresponding to entries in the plte chunk 
          Gray: 2 bytes, range 0 .. (2^bitdepth)-1 
          */ 
//            $transparency['grayscale']=$this->PRVT_getBytes($imgData,$p+8,2); // g = grayscale 
            $transparency['type']='indexed';
            $transparency['data'] = ord($imgData[$p+8+1]);
          
          } elseif($info['colorType'] == 2) { // truecolor 
          /* corresponding to entries in the plte chunk 
          Red: 2 bytes, range 0 .. (2^bitdepth)-1 
          Green: 2 bytes, range 0 .. (2^bitdepth)-1 
          Blue: 2 bytes, range 0 .. (2^bitdepth)-1 
          */ 
            $transparency['r']=$this->PRVT_getBytes($imgData,$p+8,2); // r from truecolor 
            $transparency['g']=$this->PRVT_getBytes($imgData,$p+10,2); // g from truecolor 
            $transparency['b']=$this->PRVT_getBytes($imgData,$p+12,2); // b from truecolor 
          
          } else { 
          //unsupported transparency type 
          } 
          // KS End new code 
          break; 
        default:
          break;
      }
    
      $p += $chunkLen+12;
    }
    
    if(!$haveHeader){
      $error = 1;
      $errormsg = 'information header is missing';
    }
    if (isset($info['interlaceMethod']) && $info['interlaceMethod']){
      $error = 1;
      $errormsg = 'There appears to be no support for interlaced images in pdf.';
    }
  }

  if (!$error && $info['bitDepth'] > 8){
    $error = 1;
    $errormsg = 'only bit depth of 8 or less is supported';
  }

  if (!$error){
    if ($info['colorType']!=2 && $info['colorType']!=0 && $info['colorType']!=3){
      $error = 1;
      $errormsg = 'transparancey alpha channel not supported, transparency only supported for palette images.';
    } else {
      switch ($info['colorType']){
        case 3:
          $color = 'DeviceRGB';
          $ncolor=1;
          break;
        case 2:
          $color = 'DeviceRGB';
          $ncolor=3;
          break;
        case 0:
          $color = 'DeviceGray';
          $ncolor=1;
          break;
      }
    }
  }
  if ($error){
    $this->addMessage('PNG error - '.$errormsg);
    return;
  }
  if ($w==0){
    $w=$h/$info['height']*$info['width'];
  }
  if ($h==0){
    $h=$w*$info['height']/$info['width'];
  }
//print_r($info);
  // so this image is ok... add it in.
  $this->numImages++;
  $im=$this->numImages;
  $label='I'.$im;
  $this->numObj++;
//  $this->o_image($this->numObj,'new',array('label'=>$label,'data'=>$idata,'iw'=>$w,'ih'=>$h,'type'=>'png','ic'=>$info['width']));
  $options = array('label'=>$label,'data'=>$idata,'bitsPerComponent'=>$info['bitDepth'],'pdata'=>$pdata
                                      ,'iw'=>$info['width'],'ih'=>$info['height'],'type'=>'png','color'=>$color,'ncolor'=>$ncolor);
  if (isset($transparency)){
    $options['transparency']=$transparency;
  }
  $this->o_image($this->numObj,'new',$options);

  $this->objects[$this->currentContents]['c'].="\nq";
  $this->objects[$this->currentContents]['c'].="\n".sprintf('%.3f',$w)." 0 0 ".sprintf('%.3f',$h)." ".sprintf('%.3f',$x)." ".sprintf('%.3f',$y)." cm";
  $this->objects[$this->currentContents]['c'].="\n/".$label.' Do';
  $this->objects[$this->currentContents]['c'].="\nQ";
}

/**
* add a JPEG image into the document, from a file
*/
function addJpeg($img,$x,$y,$tw,$th,$w,$h){
  $channels = 1;

  $this->addJpegImage($img,$x,$y,$tw,$th,$w,$h,$channels);
}

/**
* common code used by the two JPEG adding functions
*
* @access private
*/
function addJpegImage(&$data,$x,$y,$w=0,$h=0,$imageWidth,$imageHeight,$channels=3){
  $this->numImages++;
  $im=$this->numImages;
  $label='I'.$im;
  $this->numObj++;
  $this->o_image($this->numObj,'new',array('label'=>$label,'data'=>$data,'iw'=>$imageWidth,'ih'=>$imageHeight,'channels'=>$channels));

  $this->objects[$this->currentContents]['c'].="\nq";
  $this->objects[$this->currentContents]['c'].="\n".sprintf('%.3f',$w)." 0 0 ".sprintf('%.3f',$h)." ".sprintf('%.3f',$x)." ".sprintf('%.3f',$y)." cm";
  $this->objects[$this->currentContents]['c'].="\n/".$label.' Do';
  $this->objects[$this->currentContents]['c'].="\nQ";
}

/**
* specify where the document should open when it first starts
*/
function openHere($style,$a=0,$b=0,$c=0){
  // this function will open the document at a specified page, in a specified style
  // the values for style, and the required paramters are:
  // 'XYZ'  left, top, zoom
  // 'Fit'
  // 'FitH' top
  // 'FitV' left
  // 'FitR' left,bottom,right
  // 'FitB'
  // 'FitBH' top
  // 'FitBV' left
  $this->numObj++;
  $this->o_destination($this->numObj,'new',array('page'=>$this->currentPage,'type'=>$style,'p1'=>$a,'p2'=>$b,'p3'=>$c));
  $id = $this->catalogId;
  $this->o_catalog($id,'openHere',$this->numObj);
}

/**
* create a labelled destination within the document
*/
function addDestination($label,$style,$a=0,$b=0,$c=0){
  // associates the given label with the destination, it is done this way so that a destination can be specified after
  // it has been linked to
  // styles are the same as the 'openHere' function
  $this->numObj++;
  $this->o_destination($this->numObj,'new',array('page'=>$this->currentPage,'type'=>$style,'p1'=>$a,'p2'=>$b,'p3'=>$c));
  $id = $this->numObj;
  // store the label->idf relationship, note that this means that labels can be used only once
  $this->destinations["$label"]=$id;
}

/**
* used to add messages for use in debugging
*/
function addMessage($message){
  $this->messages.=$message."\n";
}

/**
* a few functions which should allow the document to be treated transactionally.
*/
function transaction($action){
  switch ($action){
    case 'start':
      // store all the data away into the checkpoint variable
      $data = get_object_vars($this);
      $this->checkpoint = $data;
      unset($data);
      break;
    case 'commit':
      if (is_array($this->checkpoint) && isset($this->checkpoint['checkpoint'])){
        $tmp = $this->checkpoint['checkpoint'];
        $this->checkpoint = $tmp;
        unset($tmp);
      } else {
        $this->checkpoint='';
      }
      break;
    case 'rewind':
      // do not destroy the current checkpoint, but move us back to the state then, so that we can try again
      if (is_array($this->checkpoint)){
        // can only abort if were inside a checkpoint
        $tmp = $this->checkpoint;
        foreach ($tmp as $k=>$v){
          if ($k != 'checkpoint'){
            $this->$k=$v;
          }
        }
        unset($tmp);
      }
      break;
    case 'abort':
      if (is_array($this->checkpoint)){
        // can only abort if were inside a checkpoint
        $tmp = $this->checkpoint;
        foreach ($tmp as $k=>$v){
          $this->$k=$v;
        }
        unset($tmp);
      }
      break;
  }

}

} // end of class

?>
